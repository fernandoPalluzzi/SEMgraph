% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/semCluster.R, R/semLearn.R
\name{extractClusters}
\alias{extractClusters}
\title{Cluster extraction utility}
\usage{
extractClusters(
  graph,
  data,
  membership,
  group = NULL,
  n = 2000,
  fitting.method = "lavaan",
  size = 5,
  ...
)

extractClusters(
  graph,
  data,
  membership,
  group = NULL,
  n = 2000,
  fitting.method = "lavaan",
  size = 5,
  ...
)
}
\arguments{
\item{graph}{Input network as an igraph object.}

\item{data}{A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).}

\item{membership}{A vector of cluster membership IDs. The membership 
vector can be generated using the \code{\link[SEMgraph]{clusterScore}}, 
\code{\link[SEMgraph]{clusterGraph}}, or \code{\link[SEMgraph]{model.learn}} 
functions.}

\item{group}{A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. Group specification enables node perturbation
testing. By default, \code{group = NULL}.}

\item{n}{Number of randomization replicates (default = 2000), for 
permutation flip or boostrap sampling, if algo = "ricf".}

\item{fitting.method}{MLE method used for SEM fitting. 
If algo = "lavaan" (default), the SEM will be fitted using the NLMINB solver 
from lavaan R package, with standard errors derived from the expected 
Fisher information matrix. If algo = "ricf", the model is fitted via residual 
iterative conditional fitting (RICF; Drton et al. 2009). If algo = "cggm", 
model fitting is based on constrained Gaussian Graphical Modeling 
(CGGM; Hastie et al. 2009, p. 446).}

\item{size}{Minimum size for a cluster to be fitted (default = 5). 
Use \code{size = 0} to enforce model fitting for every cluster.}

\item{...}{Currently ignored.}

\item{map}{Logical value. If TRUE, the plot of the input graph
(coloured by cluster membership) will be generated along with independent
module plots. If the input graph is very large, plotting could be
computationally intensive (by default, \code{map = FALSE}).}

\item{verbose}{Logical value. If TRUE, a plot will be showed for each
cluster.}
}
\value{
(i) clusters: list clusters as igraph objects;
(ii) fit: list of fitting results for each cluster as a lavaan object;
(iii) dfc: data.frame of summary results

A list of three objects:
\enumerate{
\item "clusters", A list of clusters as igraph objects;
\item "estimates", A data.frame containing model estimates for each cluster;
\item "fit.indices", A data.frame containing fitting indices for each cluster.
}
}
\description{
Extract and fit clusters from an input graph.

Extract and fit clusters from an input graph.
}
\examples{

\donttest{

library(huge)
als.npn <- huge.npn(alsData$exprs)

adjdata <- SEMbap(alsData$graph, als.npn)$data

# Clusters creation
clusters <- extractClusters(graph = alsData$graph, data = adjdata)
print(clusters$dfc)
head(parameterEstimates(clusters$fit$HM1))
head(parameterEstimates(clusters$fit$HM2))
head(parameterEstimates(clusters$fit$HM4))
gplot(clusters$clusters$HM2)

# Map cluster on the input graph
g <- alsData$graph
c <- clusters$clusters$HM2
V(g)$color <- ifelse(V(g)$name \%in\% V(c)$name, "gold", "white")
gplot(g)

}


\donttest{

library(huge)
als.npn <- huge.npn(alsData$exprs)

# Cluster creation
clusters <- clusterScore(graph = alsData$graph, data = als.npn,
                         group = alsData$group,
                         type = "wtc")

# Clusters extraction and fitting with the RICF algorithm
fit <- extractClusters(graph = alsData$graph, data = als.npn,
                       membership = clusters$membership,
                       group = alsData$group,
                       fitting.method = "ricf")

# Extracting differentially regulated nodes
DRNs <- rownames(fit$estimates)[fit$estimates$pvalue < 0.05]
length(DRNs)

# Map cluster 1 on the input graph
g <- alsData$graph
c <- fit$clusters[[1]]
V(g)$color <- ifelse(V(g)$name \%in\% V(c)$name, "gold", "white")
gplot(g)

}

}
\references{
Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2): 1-36.
<https://www.jstatsoft.org/v48/i02/>

Drton M, Eichler M, Richardson TS (2009). Computing Maximum Likelihood
Estimated in Recursive Linear Models with Correlated Errors.
Journal of Machine Learning Research, 10(Oct): 2329-2348.
<https://www.jmlr.org/papers/volume10/drton09a/drton09a.pdf>

Jankova J, van de Geer S (2015). Confidence intervals for high-dimensional
inverse covariance estimation. Electronic Journal of Statistics,
9(1): 1205-1229. <https://doi.org/10.1214/15-EJS1031>

Hastie T, Tibshirani R, Friedman J. (2009). The Elements of Statistical
Learning (2nd ed.). Springer Verlag: New York. ISBN: 978-0-387-84858-7

Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal Network
Analysis of High-Throughput Data with Structural Equation Models.
Bioinformatics, 38 (20), 4829â€“4830 <https://doi.org/10.1093/bioinformatics/btac567>

Fortunato S, Hric D. Community detection in networks: A user guide (2016).
Phys Rep; 659: 1-44. <https://dx.doi.org/10.1016/j.physrep.2016.09.002>

Yu M, Hillebrand A, Tewarie P, Meier J, van Dijk B, Van Mieghem P,
Stam CJ (2015). Hierarchical clustering in minimum spanning trees.
Chaos 25(2): 023107. <https://doi.org/10.1063/1.4908014>
}
\seealso{
See \code{\link[SEMgraph]{clusterScore}} and 
\code{\link[SEMgraph]{clusterGraph}} for network clustering.
See \code{\link[SEMgraph]{model.learn}} for data-driven model learning and 
clustering.
See \code{\link[SEMgraph]{SEMrun}} for general model fitting.
}
\author{
Fernando Palluzzi \email{fernando.palluzzi@gmail.com}
}
